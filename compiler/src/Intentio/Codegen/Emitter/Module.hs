{-# LANGUAGE AllowAmbiguousTypes #-}
{-# LANGUAGE QuasiQuotes #-}

module Intentio.Codegen.Emitter.Module
  ( emitModuleHeader
  , emitModuleSource
  , emitModuleHeader'
  , emitModuleSource'
  )
where

import           Intentio.Prelude

import           Data.HashSet.Lens              ( setmapped )
import qualified Data.Text                     as T
import qualified Language.C.Quote              as C
import           Language.C.Quote.C             ( cunit )
import           NeatInterpolation              ( text )

import           Intentio.Codegen.Emitter.Item  ( emitItemHeader
                                                , emitItemSource
                                                )
import           Intentio.Codegen.Emitter.Monad ( ModuleEmit
                                                , ItemEmit
                                                , askModule
                                                , runModuleEmit
                                                , runItemEmit
                                                )
import           Intentio.Codegen.Emitter.Types ( CModuleHeader
                                                , CModuleSource
                                                , CModuleDef(..)
                                                )
import           Intentio.Codegen.Emitter.Util  ( getItemById )
import           Intentio.Codegen.SymbolNames   ( GetCModuleFileName(..) )
import           Intentio.Compiler              ( CompilePure )
import qualified Intentio.Hir                  as H

emitModuleHeader :: H.Module () -> CompilePure (CModuleDef CModuleHeader)
emitModuleHeader = runModuleEmit emitModuleHeader'

emitModuleSource :: H.Module () -> CompilePure (CModuleDef CModuleSource)
emitModuleSource = runModuleEmit emitModuleSource'

emitModuleHeader' :: ModuleEmit (CModuleDef CModuleHeader)
emitModuleHeader' = emitModule emitItemHeader

emitModuleSource' :: ModuleEmit (CModuleDef CModuleSource)
emitModuleSource' = emitModule emitItemSource

emitModule
  :: forall t
   . (GetCModuleFileName t, ImportEmitter t)
  => ItemEmit [C.Definition]
  -> ModuleEmit (CModuleDef t)
emitModule itemEmitter = do
  _cModuleDefSourcePos    <- view H.moduleSourcePos
  _cModuleDefIntentioName <- view H.moduleName
  _cModuleDefFileName     <- cModuleFileName @t <$> view H.moduleName
  imports                 <- emitImports @t
  defs                    <-
    view H.moduleItemIds
    >>= mapM (getItemById >=> runItemEmit itemEmitter)
    <&> concat

  let headerText =
        toS $ buildHeaderComment _cModuleDefFileName _cModuleDefIntentioName

  let _cModuleDefDefinitions = concat
        [ [cunit| $esc:headerText |]
        , [cunit| $esc:("#include <intentio.h>") |]
        , imports
        , defs
        ]

  return CModuleDef { .. }

class ImportEmitter t where
  emitImports :: ModuleEmit [C.Definition]

instance ImportEmitter CModuleHeader where
  emitImports = pure []

instance ImportEmitter CModuleSource where
  emitImports =
    concatMap (\t -> [cunit| $esc:t |])
      .   toList
      .   (setmapped %~ inc . fst)
      .   view H.moduleImports
      <$> askModule
    where inc n = "#include \"" <> cModuleFileName @CModuleHeader n <> "\""

-- brittany-disable-next-binding
buildHeaderComment :: FilePath -> H.ModuleName -> Text
buildHeaderComment fileName (H.ModuleName moduleName) = [text|
    //$line
    // Generated by intentioc. DO NOT MODIFY!
    // File:   $fileNameS
    // Module: $moduleName
    //$line
  |]
  where
    line      = T.replicate 77 "-"
    fileNameS = toS fileName
