export classic_notation

# classic notation with minimal number of parenthesis for expressions made with (,),+,*,a,b,c


fun classic_notation (input){
    input = add_priorities(input);

    stack = "";
    while(len(input) > 0) {
        elem = cut(0, 2, input);
        input = cut(2, len(input), input);
        if(elem == "1+" or elem == "2*") {
            data1 = add_parens_if_needed(get_elem(stack), elem);
            data2 = add_parens_if_needed(get_elem(stack), elem);
            stack = cut(0, 1, elem) + cut(1, len(data1), data1) + cut(1, 2, elem) + cut(1, len(data2), data2) + stack;
        } else {
            stack = elem + stack;
        }
    }
    return cut(1, len(stack), stack);
}

# returns first elem from stack
fun get_elem(stack) {
    tmp = cut(1, len(stack), stack);
    pos1 = find("1", tmp);
    pos2 = find("2", tmp);
    pos3 = find("3", tmp);
    if (pos1 < pos2 and pos1 < pos3) { return cut(0, pos1 + 1, stack); }
    if (pos2 < pos3) { return cut(0, pos2 + 1, stack); }
    return cut(0, pos3 + 1, stack);
}

fun add_parens_if_needed(data, op) {
    if(int(cut(0, 1, data)) <  int(cut(0, 1, op))) { 
        return cut(0, 1, data) + "(" + cut(1, len(data), data) + ")";
    }
    return data1;
}

# priorities:
# + : 1
# * : 2
# a, b, c : 3
fun add_priorities(in) {
    pos = 0;
    res = "";
    while(pos < len(in)) {
        char = cut(pos, pos + 1, s);
        if(char == "+") { 
            res = res + "1+" ; 
        } else if(char == "*") { 
            res = res + "2*" ; 
        } else {
            res = res + "3" + char;
        }
    }
    return res;
}
